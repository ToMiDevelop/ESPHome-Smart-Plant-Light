esphome:
  name: smart-plant-light-esp32s-en
  friendly_name: Smart plant light EN
  on_boot:
  # Action 1: Setting initial pin states
  - priority: 1000.0 
    then:
      - output.turn_off: light_pin
      - output.turn_off: mode_pin
      - output.turn_off: color_pin
      - output.turn_off: intensity_pin
  # Action 2 2: setting globals states and initial sensor values
  - priority: -10.0
    then: 
      # Lamp off
      - globals.set: {id: light_state, value: 'false'}
      - logger.log: "Light off"
      - binary_sensor.template.publish: {id: light_state_sensor, state: !lambda 'return id(light_state);'}
      
      # Timer off
      - globals.set: {id: mode_state, value: '0'}
      - logger.log: "Hardware timer off"
      - text_sensor.template.publish: {id: Mode_timing_sensor, state: !lambda 'return std::string("Off");'}
      
      # Color full spectrum
      - globals.set: {id: color_state, value: '1'}
      - logger.log: "Full spectrum color mode"
      - text_sensor.template.publish: {id: color_mode_sensor, state: !lambda 'return std::string("Full spectrum");'}

      # Intensity 100%
      - globals.set: {id: intensity_state_now, value: '10'}
      - globals.set: {id: intensity_state_before, value: '9'}
      - sensor.template.publish: {id: intensity_sensor, state: !lambda 'return id(intensity_state_now) * 10;'}
      - logger.log: "Light intensity set to 100 %"

      # First moisture sensor publish
      - sensor.template.publish: {id: wilgotnosc, state: !lambda 'return id(average);'}

esp32:
  # board: esp32-s3-devkitc-1
  board: adafruit_feather_esp32s3
  # board: waveshare_esp32s3_pico_ota
  framework:
    type: esp-idf
    # sdkconfig_options:
    #   CONFIG_ESP32_SPIRAM_SUPPORT: "y"
    #   CONFIG_ESP32S3_USE_EMBEDDED_PSRAM: "y"

# Enable logging
logger:

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
  platform: esphome

# Allow WiFi
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Smart Plant Light"
    password: "123456789"

# Allow web server
# web_server:
#  port: 80

output:
  - platform: gpio
    pin:
      number: GPIO1
      mode: OUTPUT
      inverted: true
    id: light_pin
  - platform: gpio
    pin:
      number: GPIO2
      mode: OUTPUT
      inverted: true
    id: mode_pin
  - platform: gpio
    pin:
      number: GPIO4
      mode: OUTPUT
      inverted: true
    id: color_pin
  - platform: gpio
    pin:
      number: GPIO5
      mode: OUTPUT
      inverted: true
    id: intensity_pin

globals:
  - id: light_state
    type: bool
    restore_value: false
    initial_value: 'false' # false - off, true - on
  - id: mode_state
    type: int
    restore_value: false
    initial_value: '0' # 0 - off, 1 - timer 3 godziny, 2 - timer 9 godzin, 3 - timer 12 godzin
  - id: color_state
    type: int
    restore_value: false
    initial_value: '1' # 1 - PeÅ‚ne spektrum, 2 - red/blue, 3 - BiaÅ‚y
  - id: intensity_state_now
    type: int
    restore_value: false
    initial_value: '10' # 1-10
  - id: intensity_state_before
    type: int
    restore_value: false
    initial_value: '9' # 1-10
  - id: moisture_raw_sum
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: moisture_raw_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: last_average
    type: float
    restore_value: false
    initial_value: 'NAN'
  - id: average
    type: float
    restore_value: false
    initial_value: 'NAN'

script:
  - id: light_steering_signal_on
    mode: restart
    then:
      - logger.log: "Turn on light steering signal on light_pin"
      - output.turn_on: light_pin

  - id: light_steering_signal_off
    mode: restart
    then:
      - logger.log: "Turn off light steering signal on light_pin"
      - output.turn_off: light_pin

  - id: light_toggle
    mode: restart
    then:
      - logger.log: "Steering signal on light_pin is on"
      - output.turn_on: light_pin
      - delay: 150ms
      - output.turn_off: light_pin
      - logger.log: "Steering signal on light_pin is off"
      - lambda: |-
          if (id(light_state)) {
            id(light_state) = false;
            ESP_LOGD("custom", "Light off");
          } else {
            id(light_state) = true;
            ESP_LOGD("custom", "Light on");
          }
      - binary_sensor.template.publish:
          id: light_state_sensor
          state: !lambda 'return id(light_state);'
  
  - id: mode_toggle
    mode: restart
    then:
      - logger.log: "Steering signal on mode_pin is on"
      - output.turn_on: mode_pin
      - delay: 150ms
      - output.turn_off: mode_pin
      - logger.log: "Steering signal on mode_pin is off"
      - lambda: |-
          if (id(mode_state) == 0) {
            id(mode_state) = 1;
            ESP_LOGD("custom", "Timer mode: 3h");
          } else if (id(mode_state) == 1) {
            id(mode_state) = 2;
            ESP_LOGD("custom", "Timer mode: 9h");
          } else if (id(mode_state) == 2) {
            id(mode_state) = 3;
            ESP_LOGD("custom", "Timer mode: 12h");
          } else {
            id(mode_state) = 0;
            ESP_LOGD("custom", "Timer mode: off");
          }
      - text_sensor.template.publish:
          id: Mode_timing_sensor
          state: !lambda |-
            if (id(mode_state) == 0) {
              return std::string("Off");
            } else if (id(mode_state) == 1) {
              return std::string("3 hours");
            } else if (id(mode_state) == 2) {
              return std::string("9 hours");
            } else {
              return std::string("12 hours");
            }
  
  - id: color_toggle
    mode: restart
    then:
      - logger.log: "Steering signal on color_pin is on"
      - output.turn_on: color_pin
      - delay: 150ms
      - output.turn_off: color_pin
      - logger.log: "Steering signal on color_pin is off"
      - lambda: |-
          if (id(color_state) == 1) {
            id(color_state) = 2;
            ESP_LOGD("custom", "Color mode: Red and blue");
          } else if (id(color_state) == 2) {
            id(color_state) = 3;
            ESP_LOGD("custom", "Color mode: White");
          } else {
            id(color_state) = 1;
            ESP_LOGD("custom", "Color mode: Full spectrum");
          }
      - text_sensor.template.publish:
          id: color_mode_sensor
          state: !lambda |-
            if (id(color_state) == 1) {
              return std::string("Full spectrum");
            } else if (id(color_state) == 2) {
              return std::string("Red and blue");
            } else {
              return std::string("White");
            }
  - id: intensity_toggle
    mode: restart
    then:
      - logger.log: "Steering signal on intensity_pin is on"
      - output.turn_on: intensity_pin
      - delay: 150ms
      - output.turn_off: intensity_pin
      - logger.log: "Steering signal on intensity_pin is off"
      - lambda: |-
          if (id(intensity_state_now) == 10) {
            id(intensity_state_now) = 9;
            id(intensity_state_before) = 10;
          } else if (id(intensity_state_now) == 1) {
            id(intensity_state_now) = 2;
            id(intensity_state_before) = 1;
          } else {
            if (id(intensity_state_now) > id(intensity_state_before)) {
              id(intensity_state_before) = id(intensity_state_now);
              id(intensity_state_now) = id(intensity_state_now) + 1;
            } else {
              id(intensity_state_before) = id(intensity_state_now);
              id(intensity_state_now) = id(intensity_state_now) - 1;
            }
          ESP_LOGD("custom", "Intensywnosc swiatla ustawiona na: %d %%", id(intensity_state_now) * 10);
          }
      - sensor.template.publish:
          id: intensity_sensor
          state: !lambda 'return id(intensity_state_now) * 10;'

binary_sensor:
  - platform: template
    name: "Light state"
    id: light_state_sensor
    icon: "mdi:lightbulb"
    lambda: |-
      return id(light_state);
    internal: false

text_sensor:
  - platform: template
    name: "Light color"
    id: color_mode_sensor
    icon: "mdi:palette"
    lambda: |-
      if (id(color_state) == 1) {
        return std::string("Full spectrum");
      } else if (id(color_state) == 2) {
        return std::string("Red and blue");
      } else {
        return std::string("White");
      }
    update_interval: never
  - platform: template
    name: "Timer mode"
    id: Mode_timing_sensor
    icon: "mdi:timer"
    lambda: |-
      if (id(mode_state) == 0) {
        return std::string("Off");
      } else if (id(mode_state) == 2) {
        return std::string("3 hours");
      } else if (id(mode_state) == 3) {
        return std::string("9 hours");
      } else {
        return std::string("12 hours");
      }
    update_interval: never

sensor:
  # Light intensity (0-100%)
  - platform: template
    name: "Light intensity"
    id: intensity_sensor
    icon: "mdi:brightness-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    lambda: |-
      return id(intensity_state_now) * 10;
    update_interval: never
  # Soil humidity - reads raw from ADC and returns mean from last 30 samples
  - platform: adc
    name: "Hidden soil moisture"
    pin: GPIO6
    attenuation: 12db
    id: hidden_moisure
    unit_of_measurement: "%"
    update_interval: 10s
    internal: true
    filters:
      # Calibration
      - calibrate_linear:
          # Use your noted V for 0% humidity and 100% (pure water)
          - 2.05 -> 0.0   # Dry: V -> 0%
          - 1.3 -> 100.0 # Pure water V -> 100%
      # Getting rid of outliers
      - clamp:
          min_value: 0.0
          max_value: 100.0
      - lambda: |-
          id(moisture_raw_sum) += x;
          id(moisture_raw_count) += 1;
          if (id(moisture_raw_count) >= 30 ) {
            id(average) = id(moisture_raw_sum) / id(moisture_raw_count);
            id(last_average) = id(average);
            id(moisture_raw_sum) = 0.0;
            id(moisture_raw_count) = 0;
            return id(average);
          } else {
            return id(last_average);
          }
  # Moisture sensor visible to HA - publishing average to HA every 5 minutes
  - platform: template
    name: "Soil moisture"
    id: wilgotnosc
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 2
    update_interval: 300s
    lambda: |-
      return id(average);

button:  
  - platform: template
    name: "Light On/Off"
    id: light_button_toggle
    on_press:
      - script.execute: light_toggle
  - platform: template
    name: "Toggle light color"
    id: color_button_toggle
    on_press:
      - lambda: |-
          if (id(light_state)) {
          id(color_toggle)->execute();
          } else {
          ESP_LOGD("custom", "Light off â€” ignoring color change");
          }
  - platform: template
    name: "Toggle timer mode"
    id: mode_button_toggle
    on_press:
      - lambda: |-
          if (id(light_state)) {
          id(mode_toggle)->execute();
          } else {
          ESP_LOGD("custom", "Light off â€” ignoring timer mode change");
          }
  - platform: template
    name: "Toggle light intensity"
    id: intensity_button_toggle
    on_press:
      - lambda: |-
          if (id(light_state)) {
          id(intensity_toggle)->execute();
          } else {
          ESP_LOGD("custom", "Light off â€” ignoring intensity change");
          }