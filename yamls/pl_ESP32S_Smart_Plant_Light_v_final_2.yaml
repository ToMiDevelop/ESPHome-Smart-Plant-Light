esphome:
  name: smart-plant-light-esp32s-pl
  friendly_name: Smart plant light PL
  on_boot:
  # Action 1: Setting initial pin states
  - priority: 1000.0 
    then:
      - output.turn_off: light_pin
      - output.turn_off: mode_pin
      - output.turn_off: color_pin
      - output.turn_off: intensity_pin
  # Action 2 2: setting globals states and initial sensor values
  - priority: -10.0 # Użyj jednego bloku dla wszystkich pozostałych akcji.
    then: 
      # Lamp off
      - globals.set: {id: ligth_state, value: 'false'}
      - logger.log: "Swiatlo wylaczone"
      - binary_sensor.template.publish: {id: ligth_state_sensor, state: !lambda 'return id(ligth_state);'}
      
      # Timer off
      - globals.set: {id: mode_state, value: '0'}
      - logger.log: "Hardwaorwy sterownik czasowy wylaczony"
      - text_sensor.template.publish: {id: Mode_timing_sensor, state: !lambda 'return std::string("Wyłączony");'}
      
      # Color full spectrum
      - globals.set: {id: color_state, value: '1'}
      - logger.log: "Pelne spektrum koloru swiatla aktywne"
      - text_sensor.template.publish: {id: color_mode_sensor, state: !lambda 'return std::string("Pełne spektrum");'}

      # Intensity 100%
      - globals.set: {id: intensity_state_now, value: '10'}
      - globals.set: {id: intensity_state_before, value: '9'}
      - sensor.template.publish: {id: intensity_sensor, state: !lambda 'return id(intensity_state_now) * 10;'}
      - logger.log: "Intensywnosc swiatła ustawiona na 100 %"

      # First moisture sesnsor publish
      - sensor.template.publish: {id: wilgotnosc, state: !lambda 'return id(average);'}

esp32:
  # board: esp32-s3-devkitc-1
  board: adafruit_feather_esp32s3
  # board: waveshare_esp32s3_pico_ota
  framework:
    type: esp-idf
    # sdkconfig_options:
    #   CONFIG_ESP32_SPIRAM_SUPPORT: "y"
    #   CONFIG_ESP32S3_USE_EMBEDDED_PSRAM: "y"

# Enable logging
logger:

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
  platform: esphome

# Allow WiFi
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
# Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Smart Plant Light"
    password: "123456789"

# Allow web server
# web_server:
#  port: 80

output:
  - platform: gpio
    pin:
      number: GPIO1
      mode: OUTPUT
      inverted: true
    id: light_pin
  - platform: gpio
    pin:
      number: GPIO2
      mode: OUTPUT
      inverted: true
    id: mode_pin
  - platform: gpio
    pin:
      number: GPIO4
      mode: OUTPUT
      inverted: true
    id: color_pin
  - platform: gpio
    pin:
      number: GPIO5
      mode: OUTPUT
      inverted: true
    id: intensity_pin

globals:
  - id: ligth_state
    type: bool
    restore_value: false
    initial_value: 'false' # false - off, true - on
  - id: mode_state
    type: int
    restore_value: false
    initial_value: '0' # 0 - off, 1 - timer 3 godziny, 2 - timer 9 godzin, 3 - timer 12 godzin
  - id: color_state
    type: int
    restore_value: false
    initial_value: '1' # 1 - Pełne spektrum, 2 - red/blue, 3 - Biały
  - id: intensity_state_now
    type: int
    restore_value: false
    initial_value: '10' # 1-10
  - id: intensity_state_before
    type: int
    restore_value: false
    initial_value: '9' # 1-10
  - id: moisture_raw_sum
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: moisture_raw_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: last_average
    type: float
    restore_value: false
    initial_value: 'NAN'
  - id: average
    type: float
    restore_value: false
    initial_value: 'NAN'

script:
  - id: light_steering_signal_on
    mode: restart
    then:
      - logger.log: "Wlaczenie sygnalu sterujacego light_pin"
      - output.turn_on: light_pin

  - id: light_steering_signal_off
    mode: restart
    then:
      - logger.log: "Wylaczenie sygnalu sterujacego light_pin"
      - output.turn_off: light_pin

  - id: light_toggle
    mode: restart
    then:
      - logger.log: "Sygnal sterujacy light_pin wlaczony"
      - output.turn_on: light_pin
      - delay: 150ms
      - output.turn_off: light_pin
      - logger.log: "Sygnal sterujacy light_pin wylaczony"
      - lambda: |-
          if (id(ligth_state)) {
            id(ligth_state) = false;
            ESP_LOGD("custom", "Swiatlo wylaczone");
          } else {
            id(ligth_state) = true;
            ESP_LOGD("custom", "Swiatlo wlaczone");
          }
      - binary_sensor.template.publish:
          id: ligth_state_sensor
          state: !lambda 'return id(ligth_state);'
  
  - id: mode_toggle
    mode: restart
    then:
      - logger.log: "Sygnal sterujacy mode_pin wlaczony"
      - output.turn_on: mode_pin
      - delay: 150ms
      - output.turn_off: mode_pin
      - logger.log: "Sygnal sterujacy mode_pin wylaczony"
      - lambda: |-
          if (id(mode_state) == 0) {
            id(mode_state) = 1;
            ESP_LOGD("custom", "Tryb timera: 3h");
          } else if (id(mode_state) == 1) {
            id(mode_state) = 2;
            ESP_LOGD("custom", "Tryb timera: 9h");
          } else if (id(mode_state) == 2) {
            id(mode_state) = 3;
            ESP_LOGD("custom", "Tryb timera: 12h");
          } else {
            id(mode_state) = 0;
            ESP_LOGD("custom", "Tryb timera: wylaczony");
          }
      - text_sensor.template.publish:
          id: Mode_timing_sensor
          state: !lambda |-
            if (id(mode_state) == 0) {
              return std::string("Wyłączony");
            } else if (id(mode_state) == 1) {
              return std::string("3 godziny");
            } else if (id(mode_state) == 2) {
              return std::string("9 godzin");
            } else {
              return std::string("12 godzin");
            }
  
  - id: color_toggle
    mode: restart
    then:
      - logger.log: "Sygnal sterujacy color_pin wlaczony"
      - output.turn_on: color_pin
      - delay: 150ms
      - output.turn_off: color_pin
      - logger.log: "Sygnal sterujacy color_pin wylaczony"
      - lambda: |-
          if (id(color_state) == 1) {
            id(color_state) = 2;
            ESP_LOGD("custom", "Tryb koloru: Czerwony i niebieski");
          } else if (id(color_state) == 2) {
            id(color_state) = 3;
            ESP_LOGD("custom", "Tryb koloru: Bialy");
          } else {
            id(color_state) = 1;
            ESP_LOGD("custom", "Tryb koloru: Pelne spektrum");
          }
      - text_sensor.template.publish:
          id: color_mode_sensor
          state: !lambda |-
            if (id(color_state) == 1) {
              return std::string("Pełne spektrum");
            } else if (id(color_state) == 2) {
              return std::string("Czerwony i niebieski");
            } else {
              return std::string("Biały");
            }
  - id: intensity_toggle
    mode: restart
    then:
      - logger.log: "Sygnal sterujacy intensity_pin wlaczony"
      - output.turn_on: intensity_pin
      - delay: 150ms
      - output.turn_off: intensity_pin
      - logger.log: "Sygnal sterujacy intensity_pin wylaczony"
      - lambda: |-
          if (id(intensity_state_now) == 10) {
            id(intensity_state_now) = 9;
            id(intensity_state_before) = 10;
          } else if (id(intensity_state_now) == 1) {
            id(intensity_state_now) = 2;
            id(intensity_state_before) = 1;
          } else {
            if (id(intensity_state_now) > id(intensity_state_before)) {
              id(intensity_state_before) = id(intensity_state_now);
              id(intensity_state_now) = id(intensity_state_now) + 1;
            } else {
              id(intensity_state_before) = id(intensity_state_now);
              id(intensity_state_now) = id(intensity_state_now) - 1;
            }
          ESP_LOGD("custom", "Intensywnosc swiatla ustawiona na: %d %%", id(intensity_state_now) * 10);
          }
      - sensor.template.publish:
          id: intensity_sensor
          state: !lambda 'return id(intensity_state_now) * 10;'

binary_sensor:
  - platform: template
    name: "Stan óświetlenia"
    id: ligth_state_sensor
    icon: "mdi:lightbulb"
    lambda: |-
      return id(ligth_state);
    internal: false

text_sensor:
  - platform: template
    name: "Kolor światła"
    id: color_mode_sensor
    icon: "mdi:palette"
    lambda: |-
      if (id(color_state) == 1) {
        return std::string("Pełne spektrum");
      } else if (id(color_state) == 2) {
        return std::string("Czerwony i niebieski");
      } else {
        return std::string("Biały");
      }
    update_interval: never  # aktualizujemy ręcznie
  - platform: template
    name: "Tryb czasowy"
    id: Mode_timing_sensor
    icon: "mdi:timer"
    lambda: |-
      if (id(mode_state) == 0) {
        return std::string("Wyłączony");
      } else if (id(mode_state) == 2) {
        return std::string("3 godziny");
      } else if (id(mode_state) == 3) {
        return std::string("9 godzin");
      } else {
        return std::string("12 godzin");
      }
    update_interval: never  # aktualizujemy ręcznie

sensor:
  # Intensywność światła (0-100%)
  - platform: template
    name: "Intensywność światła"
    id: intensity_sensor
    icon: "mdi:brightness-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    lambda: |-
      return id(intensity_state_now) * 10;
    update_interval: never
  # Czujnik wilgotności gleby - ddczyt z ADC i uśrednianie - ukryte
  - platform: adc
    name: "Wilgotność podłoża ukryta"
    pin: GPIO6
    attenuation: 12db
    id: hidden_moisure
    unit_of_measurement: "%"
    update_interval: 10s
    internal: true
    filters:
      # Calibration
      - calibrate_linear:
          # Użyj tutaj swoich zanotowanych wartości napięcia V dla 0% i 100%
          - 2.05 -> 0.0   # Przykład suchego V -> 0%
          - 1.3 -> 100.0 # Przykład mokrego V -> 100%
      # Geeting rid of outliers
      - clamp:
          min_value: 0.0
          max_value: 100.0
      - lambda: |-
          id(moisture_raw_sum) += x;
          id(moisture_raw_count) += 1;
          if (id(moisture_raw_count) >= 30 ) {
            id(average) = id(moisture_raw_sum) / id(moisture_raw_count);
            id(last_average) = id(average);
            id(moisture_raw_sum) = 0.0;
            id(moisture_raw_count) = 0;
            return id(average);
          } else {
            return id(last_average);
          }
  # Czujnik wilgotności gleby - publikacja uśrednionej wartości
  - platform: template
    name: "Wilgotność podłoża"
    id: wilgotnosc
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 2
    update_interval: 300s
    lambda: |-
      return id(average);

button:  
  - platform: template
    name: "Włącz / wyłącz światło"
    id: light_button_toggle
    on_press:
      - script.execute: light_toggle
  - platform: template
    name: "Przełącz kolor światła"
    id: color_button_toggle
    on_press:
      - lambda: |-
          if (id(ligth_state)) {
          id(color_toggle)->execute();
          } else {
          ESP_LOGD("custom", "Swiatlo wylaczone — ignoruje zmiane koloru");
          }
  - platform: template
    name: "Przełącz tryb czasowy"
    id: mode_button_toggle
    on_press:
      - lambda: |-
          if (id(ligth_state)) {
          id(mode_toggle)->execute();
          } else {
          ESP_LOGD("custom", "Swiatlo wylaczone — ignoruje zmiane trybu timera");
          }
  - platform: template
    name: "Przełącz intensywność światła"
    id: intensity_button_toggle
    on_press:
      - lambda: |-
          if (id(ligth_state)) {
          id(intensity_toggle)->execute();
          } else {
          ESP_LOGD("custom", "Swiatlo wylaczone — ignoruje zmiane intensywnosci");
          }